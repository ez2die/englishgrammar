// ============================================
// ä¿®å¤å¹¶å‘é—®é¢˜çš„ä»£ç ç¤ºä¾‹
// ============================================

// æ–¹æ¡ˆ 1: ä½¿ç”¨ proper-lockfile (æ¨è)
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import lockfile from 'proper-lockfile';  // éœ€è¦: npm install proper-lockfile
import { generateSentenceAnalysis } from './server/services/geminiService.js';
import rateLimit from 'express-rate-limit';  // éœ€è¦: npm install express-rate-limit

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3001;
const QUESTIONS_DIR = path.join(__dirname, 'questions');
const QUESTIONS_FILE = path.join(QUESTIONS_DIR, 'bank.json');
const DIST_DIR = path.join(__dirname, 'dist');
const isProduction = process.env.NODE_ENV === 'production';

// Middleware
app.use(cors());
app.use(express.json());

// API é™æµä¸­é—´ä»¶
const generateLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 åˆ†é’Ÿ
  max: 10, // æ¯ä¸ª IP æœ€å¤š 10 æ¬¡è¯·æ±‚
  message: { error: 'Too many requests, please try again later.' },
  standardHeaders: true,
  legacyHeaders: false,
});

// Ensure questions directory exists
async function ensureQuestionsDir() {
  try {
    await fs.mkdir(QUESTIONS_DIR, { recursive: true });
    try {
      await fs.access(QUESTIONS_FILE);
    } catch {
      await fs.writeFile(QUESTIONS_FILE, JSON.stringify([], null, 2));
    }
  } catch (error) {
    console.error('Failed to initialize questions directory:', error);
  }
}

// ä¿®å¤åçš„è¯»å–å‡½æ•°ï¼ˆæ·»åŠ é‡è¯•æœºåˆ¶ï¼‰
async function readQuestions() {
  let retries = 3;
  while (retries > 0) {
    try {
      const data = await fs.readFile(QUESTIONS_FILE, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      retries--;
      if (retries === 0) {
        console.error('Failed to read questions after retries:', error);
        throw error;
      }
      // ç­‰å¾…åé‡è¯•
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
}

// ä¿®å¤åçš„å†™å…¥å‡½æ•°ï¼ˆä½¿ç”¨æ–‡ä»¶é”ï¼‰
async function writeQuestions(questions) {
  let release;
  try {
    // è·å–æ–‡ä»¶é”ï¼Œæœ€å¤šç­‰å¾… 10 ç§’
    release = await lockfile.lock(QUESTIONS_FILE, {
      retries: {
        retries: 20,
        minTimeout: 100,
        maxTimeout: 500
      },
      lockfilePath: QUESTIONS_FILE + '.lock'
    });
    
    // é‡æ–°è¯»å–æœ€æ–°æ•°æ®ï¼ˆé˜²æ­¢åœ¨ç­‰å¾…é”æœŸé—´æ•°æ®å·²æ›´æ–°ï¼‰
    const currentQuestions = await readQuestions();
    
    // åˆå¹¶æ•°æ®ï¼ˆå»é‡ï¼‰
    const questionMap = new Map();
    currentQuestions.forEach(q => {
      questionMap.set(q.originalSentence, q);
    });
    
    // æ·»åŠ æ–°é—®é¢˜
    if (Array.isArray(questions)) {
      questions.forEach(q => {
        if (!questionMap.has(q.originalSentence)) {
          questionMap.set(q.originalSentence, q);
        }
      });
    } else {
      // å•ä¸ªé—®é¢˜
      if (!questionMap.has(questions.originalSentence)) {
        questionMap.set(questions.originalSentence, questions);
      }
    }
    
    const updatedQuestions = Array.from(questionMap.values());
    
    // åŸå­å†™å…¥ï¼ˆå…ˆå†™å…¥ä¸´æ—¶æ–‡ä»¶ï¼Œç„¶åé‡å‘½åï¼‰
    const tempFile = QUESTIONS_FILE + '.tmp';
    await fs.writeFile(tempFile, JSON.stringify(updatedQuestions, null, 2), 'utf-8');
    await fs.rename(tempFile, QUESTIONS_FILE);
    
    return true;
  } catch (error) {
    console.error('Failed to write questions:', error);
    return false;
  } finally {
    if (release) {
      try {
        await release();
      } catch (e) {
        console.error('Failed to release lock:', e);
      }
    }
  }
}

// è¿½åŠ å•ä¸ªé—®é¢˜ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
async function appendQuestion(newQuestion) {
  let release;
  try {
    // è·å–æ–‡ä»¶é”
    release = await lockfile.lock(QUESTIONS_FILE, {
      retries: {
        retries: 20,
        minTimeout: 100,
        maxTimeout: 500
      },
      lockfilePath: QUESTIONS_FILE + '.lock'
    });
    
    // è¯»å–æœ€æ–°æ•°æ®
    const questions = await readQuestions();
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const exists = questions.some(q => q.originalSentence === newQuestion.originalSentence);
    if (exists) {
      return { success: false, message: 'Question already exists', count: questions.length };
    }
    
    // æ·»åŠ æ–°é—®é¢˜
    questions.push(newQuestion);
    
    // åŸå­å†™å…¥
    const tempFile = QUESTIONS_FILE + '.tmp';
    await fs.writeFile(tempFile, JSON.stringify(questions, null, 2), 'utf-8');
    await fs.rename(tempFile, QUESTIONS_FILE);
    
    return { success: true, message: 'Question saved', count: questions.length };
  } catch (error) {
    console.error('Failed to append question:', error);
    return { success: false, message: 'Failed to save question', error: error.message };
  } finally {
    if (release) {
      try {
        await release();
      } catch (e) {
        console.error('Failed to release lock:', e);
      }
    }
  }
}

// API Routes

// GET /api/questions - Get all questions
app.get('/api/questions', async (req, res) => {
  try {
    const questions = await readQuestions();
    res.json(questions);
  } catch (error) {
    res.status(500).json({ error: 'Failed to load questions' });
  }
});

// POST /api/questions - Save a new question (ä¿®å¤å)
app.post('/api/questions', async (req, res) => {
  try {
    const newQuestion = req.body;
    const result = await appendQuestion(newQuestion);
    
    if (result.success) {
      res.json({ message: result.message, count: result.count });
    } else {
      if (result.message === 'Question already exists') {
        res.json({ message: result.message, count: result.count });
      } else {
        res.status(500).json({ error: result.message });
      }
    }
  } catch (error) {
    res.status(500).json({ error: 'Failed to save question' });
  }
});

// GET /api/questions/random - Get a random question
app.get('/api/questions/random', async (req, res) => {
  try {
    const { level, excludeSentence } = req.query;
    const questions = await readQuestions();
    
    if (questions.length === 0) {
      return res.json(null);
    }
    
    let candidates = questions;
    
    // Filter by level if provided
    if (level) {
      candidates = questions.filter(q => {
        const qLevel = q.level || 'Advanced';
        return qLevel === level;
      });
    }
    
    // Exclude specific sentence if provided
    if (excludeSentence) {
      const filtered = candidates.filter(q => q.originalSentence !== excludeSentence);
      if (filtered.length > 0) {
        candidates = filtered;
      } else {
        return res.json(null);
      }
    }
    
    if (candidates.length === 0) {
      return res.json(null);
    }
    
    const randomIndex = Math.floor(Math.random() * candidates.length);
    res.json(candidates[randomIndex]);
  } catch (error) {
    res.status(500).json({ error: 'Failed to get random question' });
  }
});

// GET /api/questions/size - Get bank size
app.get('/api/questions/size', async (req, res) => {
  try {
    const { level } = req.query;
    const questions = await readQuestions();
    
    if (!level) {
      return res.json({ size: questions.length });
    }
    
    const filtered = questions.filter(q => {
      const qLevel = q.level || 'Advanced';
      return qLevel === level;
    });
    
    res.json({ size: filtered.length });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get bank size' });
  }
});

// POST /api/generate - Generate sentence analysis using Gemini (æ·»åŠ é™æµ)
app.post('/api/generate', generateLimiter, async (req, res) => {
  try {
    const { level } = req.body;
    
    if (!level) {
      return res.status(400).json({ error: 'Level is required' });
    }

    const result = await generateSentenceAnalysis(level);
    res.json(result);
    
  } catch (error) {
    console.error("Failed to generate sentence analysis:", error);
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯é™æµé”™è¯¯
    if (error.status === 429) {
      return res.status(429).json({ error: 'Too many requests, please try again later.' });
    }
    
    res.status(500).json({ error: 'Failed to generate sentence analysis', details: error.message });
  }
});

// Start server
async function startServer() {
  await ensureQuestionsDir();
  
  // Serve static files in production
  if (isProduction) {
    try {
      await fs.access(DIST_DIR);
      app.use(express.static(DIST_DIR));
      
      // Handle React Router - serve index.html for all non-API routes
      app.get('*', (req, res) => {
        if (!req.path.startsWith('/api')) {
          res.sendFile(path.join(DIST_DIR, 'index.html'));
        }
      });
      console.log(`ğŸ“¦ Serving static files from: ${DIST_DIR}`);
    } catch (error) {
      console.warn(`âš ï¸  Dist directory not found. Run 'npm run build' first.`);
    }
  }
  
  app.listen(PORT, '0.0.0.0', () => {
    console.log(`ğŸ“š Question Bank API server running on http://0.0.0.0:${PORT}`);
    console.log(`ğŸ“ Questions stored in: ${QUESTIONS_DIR}`);
    if (isProduction) {
      console.log(`ğŸŒ Production mode enabled`);
    }
    console.log(`ğŸ”’ File locking enabled for concurrent safety`);
  });
}

startServer().catch(console.error);
